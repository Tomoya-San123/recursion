# 第5回課題　バイナリと再帰関数

## 課題1 (/helloworld)
### 実行方法

```
make
./helloworld1
```

### 実装内容
- calc_magicnumber.c では"Hello,World!\n"の文字列を無理やりfloat*でキャストしてあげることで、整数値に変換した。
- これで表示した内容を直接helloworld1.cに貼り付けると、floatの上限を超えてしまうため、変換したものをkeyというfloat配列のアドレスを返す関数magicnumber()を作り、それをmain関数内で用いている。

---

## 課題2 (/fibo)
### 実行方法
- makeを実行したあと、コンパイルによってfiboファイルが生成される。
- 標準入力で0から90の間の整数nを入力することでn番目のフィボナッチ数が表示される。
- また、範囲外の整数を入力すると実行されない。
```
make
./fibo 12
```

### fibo.cの内容
- 関数mulmatmat()は2x2の行列同士の積を求める。
- 関数calc_A()は再帰が利用されていて、行列A(n)を求める。
- 関数fibo()はn=0,1の時だけ例外処理を行い、それ以上はcalc_AによりA(n)を求め、n番目のフィボナッチ数にあたる左上成分をmain関数に渡す。
---

## 課題3 (/knapsack1)
- 検証用のバイナリファイルを作るためにmakebinary.cをbin内に同梱した。
- 下のコマンドにより、items.binという、5品分のデータが記述されたバイナリファイルが作成される。 

```
./makebinary
```

- バイナリファイルを読み取る関数はitem.c内のload_itemset()とした。
- 指定通りに品数、品数分の価値、品数分の重さを順番に読み取り、構造体に書き込んでいった。
- make後、以下のコマンドにより、挙動が確認できる

```
bin/knapsack bin/items.bin 20
```
---

## 課題4 (/tsp1)
- 元々のsolve()関数を利用して、新たな関数であるinit_route()とexchange_route()を組み合わせて実装した。

### init_route() の実装
- init_route()は初期値を設定している。
- 始点0は固定し、それ以外は乱数によってランダムに並べている。
- 重複なく並べるために、numiscalledというリストによってすでに呼ばれた都市をビット管理している。
- また、後々の比較のために、初期値での距離も表示している。

### exchange_route() の実装
- 都市番号を２つ入力すると、そこを交換してくれる。

### solve() の実装
- 局所解に辿り着いたかどうかは300回連続で都市交換がされなかった場合で判定している。(変数optcntによる)
- 乱数により、交換する2都市を選んでいる。
- 都市交換前と交換後で距離を比較し、より小さい方を採用する。


> 詳しい考察は ./tsp1/tsp1.mdにあります。

## 課題5 (/advance)
### ナップサック問題 - 動的計画法
- solve()関数の中身を動的計画法で行った。
- i番目の品物を入れるか入れないかを考え、i+1を再帰で呼び出すことで品物数を減らした問題に分割して行っている。
- 解が自明になったら0を返して関数を終了するようにしている。

