# 第5回課題　バイナリと再帰関数

## 課題1 (/helloworld)

---

## 課題2 (/fibo)
### 実行方法
- makeを実行したあと、コンパイルによってfiboファイルが生成される。
- 標準入力で0から90の間の整数nを入力することでn番目のフィボナッチ数が表示される。
- また、範囲外の整数を入力すると実行されない。
```
make
./fibo 12
```

### fibo.cの内容
- 関数mulmatmat()は2x2の行列同士の積を求める。
- 関数calc_A()は再帰が利用されていて、行列A(n)を求める。
- 関数fibo()はn=0,1の時だけ例外処理を行い、それ以上はcalc_AによりA(n)を求め、n番目のフィボナッチ数にあたる左上成分をmain関数に渡す。
---

## 課題3 (/knapsack1)

---

## 課題4 (/tsp1)
- 元々のsolve()関数を利用して、新たな関数であるinit_route()とexchange_route()を組み合わせて実装した。

### init_route() の実装
- init_route()は初期値を設定している。
- 始点0は固定し、それ以外は乱数によってランダムに並べている。
- 重複なく並べるために、numiscalledというリストによってすでに呼ばれた都市をビット管理している。
- また、後々の比較のために、初期値での距離も表示している。

### exchange_route() の実装
- 都市番号を２つ入力すると、そこを交換してくれる。

### solve() の実装
- 局所解に辿り着いたかどうかは300回連続で都市交換がされなかった場合で判定している。(変数optcntによる)
- 乱数により、交換する2都市を選んでいる。
- 都市交換前と交換後で距離を比較し、より小さい方を採用する。


> 詳しい考察は ./tsp1/tsp1.mdにあります。

